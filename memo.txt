**TODO

* スタックのポインタを取得できるようにする
* ポインタアクセスが容量を食い過ぎる
* Bug: "//\n" の行でエラー
* pointerのインデックスがうまく動かない？ index_p{set|get}がだめっぽい
* Bug: int16 + int8 が動かん
* <<, >> 演算子
*ポインタ演算の追加
*sizeof()の実装
*グローバル変数の初期化
*functionにスタックを使わないオプションを追加する(ただし、内部で関数は呼べない)
*constの２重配列、ポインタ配列などに対応
*';'省略
*'('省略
*インライン関数
*goto文

*クロージャの追加
*include/optionsの整理(fc,asm,chr, rb(マクロ) )


-マクロ
-ブロックスコープを追加
-ステータスレジスタ最適化
-ブランチが+-128以上にとべるように(自動で選択できるように)
  beqx のような命令をアセンブラに追加して、あとで変換する
- *,& の実装
-switch文をつくる
-lambdaを追加
-配列リテラル、文字列リテラルなどをvalではなく、別の位置に保管するようにする
-符号拡張をちゃんとする(けっこう厄介,変換機構が必要)
-options でバンク数などの指定を調整する
-arrayからpointerへの自動変換のコードを整理(Value.kindになにか追加する？)
-メモリの重複割り当て
-lambdaを値として取れるようにする（引数の汎用化が必須)
-配列サイズの省略(初期化式ありのみ）
-signedの導入
-型補完をいれる
-/,*,&,|,&&,||の実装
-aレジスタの最適化
-indexのサイズを反映
-include_binを追加
-配列の初期化
-index/pget/psetの最適化
-callの複数引数化
-returnをちゃんとする
-voidをいれる



** ジェネリックのアイデア

1 + 2
  -> [ 1, 2 ]."+"(){}
    -> [:'+', [1:int,2:int], [], {}]

obj.method( x, y )
  -> [ obj ].method( x, y ){}
    -> [:method, [obj:class], [:x, :y], {}]

[a,b].remove()
    -> [ a:obj, b:obj ].remove(){}
      -> [:remove, [a:obj, b:obj], [], {}]

some_func( a, b + 1 ){}
  -> [].some_func( a, b )
    -> [:some_func, [], [:a, :b] , {} ]

a.hoge().fuga()
  -> [a].hoge(
  

{}はタプル
タプルのメソッドはオーバーロード可能

構成要素は、
  [:call ,メソッド名, タプル(評価済み), 引数リスト(未評価), ブロックリスト ]
メソッドは、通常の関数か、マクロ
マクロの場合は、引数は評価されない。通常の関数の場合は評価されてから送られる。


**クロック数
CPU = 1.79MHz

水平同期あたりクロック数 =   113 clock (= 340PPU clock )
垂直同期あたりクロック数 = 29833 clock
vblankクロック数         =  2505 clock

